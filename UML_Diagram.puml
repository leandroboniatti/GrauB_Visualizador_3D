@startuml Visualizador3D_ClassDiagram

' Configurações de estilo
skinparam classAttributeIconSize 0
skinparam class {
    BackgroundColor #FEFEFE
    BorderColor #666666
    ArrowColor #333333
}

' ============================================
' STRUCTS
' ============================================

class Material <<struct>> {
  + name : string
  + Ka : vec3
  + Kd : vec3
  + Ks : vec3
  + Ns : float
  + map_Kd : string
  + Material()
  + Material(name, ambient, diffuse, specular, shininess, texture)
  + hasTexture() : bool
}

class BoundingBox <<struct>> {
  + min : vec3
  + max : vec3
  + BoundingBox()
  + expand(point : vec3) : void
  + center() : vec3
  + size() : vec3
  + radius() : float
}

class ObjectInfo <<struct>> {
  + name : string
  + modelPath : string
  + position : vec3
  + rotation : vec3
  + scale : vec3
  + eliminable : bool
}

' ============================================
' CLASSES PRINCIPAIS
' ============================================

class System {
  - window : GLFWwindow*
  - sceneObject : Object3D*
  - deltaTime : float
  - lastFrame : float
  - keys : bool[1024]
  - firstMouse : bool
  - lastX : float
  - lastY : float
  + {static} SCREEN_WIDTH : const unsigned int
  + {static} SCREEN_HEIGHT : const unsigned int
  + camera : Camera
  + mainShader : Shader
  + lightPos : vec3
  + lightColor : vec3
  + attConstant : float
  + attLinear : float
  + attQuadratic : float
  + fogColor : vec3
  + fogDensity : float
  + fogStart : float
  + fogEnd : float
  + fogType : int
  + sceneObjects : vector<unique_ptr<Object3D>>
  + projeteis : vector<unique_ptr<Projetil>>
  + System()
  + ~System()
  + initializeGLFW() : bool
  + initializeOpenGL() : bool
  + loadShaders() : bool
  + loadSceneObjects() : bool
  + processInput() : void
  + render() : void
  + shutdown() : void
  + disparo() : void
  + updateProjeteis() : void
  + checkCollisions() : void
  + {static} framebuffer_size_callback(...) : void
  + {static} mouse_callback(...) : void
  + {static} scroll_callback(...) : void
  + {static} key_callback(...) : void
}

class Object3D {
  + mesh : Mesh
  + transform : mat4
  + position : vec3
  + rotation : vec3
  + scale : vec3
  + eliminable : bool
  + name : string
  + Object3D()
  + Object3D(objName : string&)
  + ~Object3D()
  + loadObject(path : string&) : bool
  + render(shader : Shader&) : void
  + setPosition(pos : vec3&) : void
  + setRotation(rot : vec3&) : void
  + setScale(scl : vec3&) : void
  + setEliminable(canEliminate : bool) : void
  + getPosition() : vec3
  + getRotation() : vec3
  + getScale() : vec3
  + isEliminable() : bool
  + getTransformedBoundingBox() : BoundingBox
  + rayIntersect(...) : bool
  + updateTransform() : void
}

class Mesh {
  + vertices : vector<vec3>
  + texCoords : vector<vec2>
  + normals : vector<vec3>
  + groups : vector<Group>
  + materials : map<string, Material>
  + boundingBox : BoundingBox
  + Mesh()
  + ~Mesh()
  + readObjectModel(path : string&) : bool
  + setupBuffers() : void
  + render(shader : Shader&) : void
  + cleanup() : void
  + calculateBoundingBox() : void
  + rayIntersect(...) : bool
  + calculateFaceNormal(...) : vec3
}

class Group {
  + name : string
  + faces : vector<Face>
  + material : Material
  + VAO : unsigned int
  + VBO : unsigned int
  + textureID : unsigned int
  + vertices : vector<float>
  + vertexCount : int
  + Group()
  + Group(groupName : string&)
  + ~Group()
  + addFace(face : Face&) : void
  + setupBuffers(...) : void
  + render(shader : Shader&) : void
  + loadMaterialTexture(modelDirectory : string&) : void
  + cleanup() : void
}

class Face {
  + vertexIndices : vector<unsigned int>
  + textureIndices : vector<unsigned int>
  + normalIndices : vector<unsigned int>
  + Face()
  + Face(vIndices, tIndices, nIndices) : Face
  + triangulate() : vector<Face>
}

class OBJReader {
  + {static} readFileOBJ(...) : bool
  + {static} readFileMTL(...) : bool
  + {static} split(str : string&, delimiter : char) : vector<string>
  + {static} trim(str : string&) : string
  + {static} getDirectory(filepath : string&) : string
  + {static} parseFace(...) : void
  + {static} parseVertice(...) : void
  + {static} parseTexCoord(...) : void
}

class Shader {
  + ID : unsigned int
  + Shader()
  + Shader(vertexPath : string&, fragmentPath : string&)
  + ~Shader()
  + loadFromFiles(...) : bool
  + loadFromStrings(...) : bool
  + use() : void
  + setBool(name : string&, value : bool) : void
  + setInt(name : string&, value : int) : void
  + setFloat(name : string&, value : float) : void
  + setVec3(name : string&, value : vec3&) : void
  + setVec3(name : string&, x, y, z : float) : void
  + setMat4(name : string&, mat : mat4&) : void
  - readFile(filePath : string&) : string
  - compileShader(...) : unsigned int
  - checkCompileErrors(...) : bool
  - cleanup() : void
}

class Texture {
  + {static} loadTexture(path : string&) : unsigned int
}

class Camera {
  + Position : vec3
  + Front : vec3
  + Up : vec3
  + Right : vec3
  + WorldUp : vec3
  + Yaw : float
  + Pitch : float
  + MovementSpeed : float
  + MouseSensitivity : float
  + Zoom : float
  + Camera(position, up, yaw, pitch)
  + GetViewMatrix() : mat4
  + ProcessKeyboard(direction : Camera_Movement, deltaTime : float) : void
  + ProcessMouseMovement(xoffset, yoffset : float, constrainPitch : bool) : void
  + ProcessMouseScroll(yoffset : float) : void
  + updateCameraVectors() : void
}

class Projetil {
  + position : vec3
  + direction : vec3
  + speed : float
  + lifetime : float
  + maxLifetime : float
  + active : bool
  + VAO : unsigned int
  + VBO : unsigned int
  + Projetil()
  + Projetil(startPos, dir : vec3&, projetilSpeed, maxLife : float)
  + ~Projetil()
  + update(deltaTime : float) : void
  + draw(shader : Shader&) : void
  + isActive() : bool
  + reflect(normal : vec3&) : void
  + desativar() : void
  + setupMesh() : void
  + cleanup() : void
}

enum Camera_Movement {
  FORWARD
  BACKWARD
  LEFT
  RIGHT
}

' ============================================
' RELACIONAMENTOS
' ============================================

' System tem composição com Camera, Shader e ObjectInfo
System *-- Camera : contém
System *-- Shader : contém
System ..> ObjectInfo : usa

' System gerencia coleções de Object3D e Projetil
System o-- "0..*" Object3D : gerencia >
System o-- "0..*" Projetil : gerencia >

' Object3D contém Mesh
Object3D *-- Mesh : possui

' Mesh contém Groups, Materials e BoundingBox
Mesh *-- "1..*" Group : possui
Mesh o-- "0..*" Material : referencia
Mesh *-- BoundingBox : possui

' Group contém Faces e Material
Group *-- "1..*" Face : contém
Group *-- Material : possui

' OBJReader é usado por Mesh para carregar dados
Mesh ..> OBJReader : <<usa>>
OBJReader ..> Material : <<cria>>
OBJReader ..> Face : <<cria>>
OBJReader ..> Group : <<cria>>

' Group usa Texture para carregar texturas
Group ..> Texture : <<usa>>

' Shader é usado por Object3D, Group e Projetil para renderização
Object3D ..> Shader : <<usa>>
Group ..> Shader : <<usa>>
Projetil ..> Shader : <<usa>>

' Camera usa enum Camera_Movement
Camera ..> Camera_Movement : <<usa>>

note top of System
  Classe principal que gerencia:
  - Inicialização GLFW/OpenGL
  - Loop de renderização
  - Iluminação Phong (ambiente + difusa + especular + atenuação + fog)
  - Entrada de usuário (teclado/mouse)
  - Disparo de projéteis
  - Detecção de colisões
end note

note top of Material
  Representa propriedades de material MTL:
  - Ka: reflexão ambiente
  - Kd: reflexão difusa
  - Ks: reflexão especular
  - Ns: brilho especular
  - map_Kd: textura difusa
end note

note bottom of OBJReader
  Classe utilitária estática para:
  - Leitura de arquivos OBJ
  - Leitura de arquivos MTL
  - Parse de vértices, texturas, normais e faces
end note

@enduml
